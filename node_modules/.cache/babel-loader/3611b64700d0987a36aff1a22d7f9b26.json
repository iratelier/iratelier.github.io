{"ast":null,"code":"import _createForOfIteratorHelper from \"/Users/miracle/Documents/GitHub/iratelier.github.io/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _createClass from \"/Users/miracle/Documents/GitHub/iratelier.github.io/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _classCallCheck from \"/Users/miracle/Documents/GitHub/iratelier.github.io/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _inherits from \"/Users/miracle/Documents/GitHub/iratelier.github.io/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"/Users/miracle/Documents/GitHub/iratelier.github.io/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\n\n/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { Route } from 'workbox-routing/Route.js';\nimport { generateURLVariations } from './utils/generateURLVariations.js';\nimport './_version.js';\n/**\n * A subclass of {@link workbox-routing.Route} that takes a\n * {@link workbox-precaching.PrecacheController}\n * instance and uses it to match incoming requests and handle fetching\n * responses from the precache.\n *\n * @memberof workbox-precaching\n * @extends workbox-routing.Route\n */\n\nvar PrecacheRoute = /*#__PURE__*/function (_Route) {\n  _inherits(PrecacheRoute, _Route);\n\n  var _super = _createSuper(PrecacheRoute);\n\n  /**\n   * @param {PrecacheController} precacheController A `PrecacheController`\n   * instance used to both match requests and respond to fetch events.\n   * @param {Object} [options] Options to control how requests are matched\n   * against the list of precached URLs.\n   * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n   * check cache entries for a URLs ending with '/' to see if there is a hit when\n   * appending the `directoryIndex` value.\n   * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An\n   * array of regex's to remove search params when looking for a cache match.\n   * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n   * check the cache for the URL with a `.html` added to the end of the end.\n   * @param {workbox-precaching~urlManipulation} [options.urlManipulation]\n   * This is a function that should take a URL and return an array of\n   * alternative URLs that should be checked for precache matches.\n   */\n  function PrecacheRoute(precacheController, options) {\n    _classCallCheck(this, PrecacheRoute);\n\n    var match = function match(_ref) {\n      var request = _ref.request;\n      var urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n\n      var _iterator = _createForOfIteratorHelper(generateURLVariations(request.url, options)),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var possibleURL = _step.value;\n          var cacheKey = urlsToCacheKeys.get(possibleURL);\n\n          if (cacheKey) {\n            var integrity = precacheController.getIntegrityForCacheKey(cacheKey);\n            return {\n              cacheKey: cacheKey,\n              integrity: integrity\n            };\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (process.env.NODE_ENV !== 'production') {\n        logger.debug(\"Precaching did not find a match for \" + getFriendlyURL(request.url));\n      }\n\n      return;\n    };\n\n    return _super.call(this, match, precacheController.strategy);\n  }\n\n  return _createClass(PrecacheRoute);\n}(Route);\n\nexport { PrecacheRoute };","map":{"version":3,"sources":["/Users/miracle/Documents/GitHub/iratelier.github.io/node_modules/workbox-precaching/PrecacheRoute.js"],"names":["logger","getFriendlyURL","Route","generateURLVariations","PrecacheRoute","precacheController","options","match","request","urlsToCacheKeys","getURLsToCacheKeys","url","possibleURL","cacheKey","get","integrity","getIntegrityForCacheKey","process","env","NODE_ENV","debug","strategy"],"mappings":";;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,iCAAvB;AACA,SAASC,cAAT,QAA+B,yCAA/B;AACA,SAASC,KAAT,QAAsB,0BAAtB;AACA,SAASC,qBAAT,QAAsC,kCAAtC;AACA,OAAO,eAAP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACMC,a;;;;;AACF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,yBAAYC,kBAAZ,EAAgCC,OAAhC,EAAyC;AAAA;;AACrC,QAAMC,KAAK,GAAG,SAARA,KAAQ,OAAkB;AAAA,UAAfC,OAAe,QAAfA,OAAe;AAC5B,UAAMC,eAAe,GAAGJ,kBAAkB,CAACK,kBAAnB,EAAxB;;AAD4B,iDAEFP,qBAAqB,CAACK,OAAO,CAACG,GAAT,EAAcL,OAAd,CAFnB;AAAA;;AAAA;AAE5B,4DAAuE;AAAA,cAA5DM,WAA4D;AACnE,cAAMC,QAAQ,GAAGJ,eAAe,CAACK,GAAhB,CAAoBF,WAApB,CAAjB;;AACA,cAAIC,QAAJ,EAAc;AACV,gBAAME,SAAS,GAAGV,kBAAkB,CAACW,uBAAnB,CAA2CH,QAA3C,CAAlB;AACA,mBAAO;AAAEA,cAAAA,QAAQ,EAARA,QAAF;AAAYE,cAAAA,SAAS,EAATA;AAAZ,aAAP;AACH;AACJ;AAR2B;AAAA;AAAA;AAAA;AAAA;;AAS5B,UAAIE,OAAO,CAACC,GAAR,CAAYC,QAAZ,KAAyB,YAA7B,EAA2C;AACvCnB,QAAAA,MAAM,CAACoB,KAAP,CAAa,yCAAyCnB,cAAc,CAACO,OAAO,CAACG,GAAT,CAApE;AACH;;AACD;AACH,KAbD;;AADqC,6BAe/BJ,KAf+B,EAexBF,kBAAkB,CAACgB,QAfK;AAgBxC;;;EAjCuBnB,K;;AAmC5B,SAASE,aAAT","sourcesContent":["/*\n  Copyright 2020 Google LLC\n\n  Use of this source code is governed by an MIT-style\n  license that can be found in the LICENSE file or at\n  https://opensource.org/licenses/MIT.\n*/\nimport { logger } from 'workbox-core/_private/logger.js';\nimport { getFriendlyURL } from 'workbox-core/_private/getFriendlyURL.js';\nimport { Route } from 'workbox-routing/Route.js';\nimport { generateURLVariations } from './utils/generateURLVariations.js';\nimport './_version.js';\n/**\n * A subclass of {@link workbox-routing.Route} that takes a\n * {@link workbox-precaching.PrecacheController}\n * instance and uses it to match incoming requests and handle fetching\n * responses from the precache.\n *\n * @memberof workbox-precaching\n * @extends workbox-routing.Route\n */\nclass PrecacheRoute extends Route {\n    /**\n     * @param {PrecacheController} precacheController A `PrecacheController`\n     * instance used to both match requests and respond to fetch events.\n     * @param {Object} [options] Options to control how requests are matched\n     * against the list of precached URLs.\n     * @param {string} [options.directoryIndex=index.html] The `directoryIndex` will\n     * check cache entries for a URLs ending with '/' to see if there is a hit when\n     * appending the `directoryIndex` value.\n     * @param {Array<RegExp>} [options.ignoreURLParametersMatching=[/^utm_/, /^fbclid$/]] An\n     * array of regex's to remove search params when looking for a cache match.\n     * @param {boolean} [options.cleanURLs=true] The `cleanURLs` option will\n     * check the cache for the URL with a `.html` added to the end of the end.\n     * @param {workbox-precaching~urlManipulation} [options.urlManipulation]\n     * This is a function that should take a URL and return an array of\n     * alternative URLs that should be checked for precache matches.\n     */\n    constructor(precacheController, options) {\n        const match = ({ request, }) => {\n            const urlsToCacheKeys = precacheController.getURLsToCacheKeys();\n            for (const possibleURL of generateURLVariations(request.url, options)) {\n                const cacheKey = urlsToCacheKeys.get(possibleURL);\n                if (cacheKey) {\n                    const integrity = precacheController.getIntegrityForCacheKey(cacheKey);\n                    return { cacheKey, integrity };\n                }\n            }\n            if (process.env.NODE_ENV !== 'production') {\n                logger.debug(`Precaching did not find a match for ` + getFriendlyURL(request.url));\n            }\n            return;\n        };\n        super(match, precacheController.strategy);\n    }\n}\nexport { PrecacheRoute };\n"]},"metadata":{},"sourceType":"module"}